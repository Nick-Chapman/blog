
# Typing Forth

Can we type-check Forth? This is the question I tried to avoid for in my early weeks
diving down the [Forth Rabbt Hole](1.rabbit.md).
Type checking is not something which is part of the classical essence of Forth.
But on the other hand there is nothing which makes Forth incompatible with Type checking
At least not the kind of static type checking I have in mind.

Even in my early weeks struggling to write Forth code, it was clear that some programming mistakes are just glaringly obvious. Or at least they would be to a super human who could track perfectly the stack effect of every Forth word. Sadly I am not that super human.

### Balancing a useful type system

Coming from the world of statically typed Function programming languages, I have long seen types as an incredibly helpful tool for constructing programs for which we can be sure, contain no errors of a certain class - so called typed errors.

Not all errors for sure. Divide by zero, and unbounded recursion are examples of _run-time_ errors which wont be detected by a type system.
By definition, any error which is not detected by a type system, is not a type error.
Why would we not detect such errors? In short because it is either (a) too difficult, or (b) detecting such errors would detect/reject other programs which do not go wrong at runtime, but which cannot be distinguished from real errors.

So there is a balance to strike. And this balance is manifest in the design on any given type system.
So can we come up with a useful type system for Forth?

Here useful means:
- (1) The type system will statically detect some manifest errors.
- (2) The type system should only reject a programs which goes wrong at runtime.

Sometimes we are happy to mitigate falsely rejected programs by either
- (a) slightly rewriting out programs in a style which appeases the type system
- (b) adding some kind of annotation to the program which says, _"Hey type checker, don't worry!"_

Of course we would prefer not to have to do either of these things, by designing a _really good_ type system. But (1) and (2) pull in opposing directions. It's a balance.


### Type Errors

So what errors should we detect? And what happens if we run a Forth program containing such errors.
The most common error which we might write in Forth is where we fail to track the stack correctly.
Perhaps we forget a `dup` or a `drop`. Or maybe we need a `swap` to get our arguments in the correct order.
A missing `drop` or `dup` can often be catastrophic. All subsequent code will be consuming incorrect values from the stack. That is ok when the values are numeric, but when they are expected to be an address or worse an execution token, all hell can break loose.
A missing or incorrectly added `swap` might just cause the wrong answer to be computed. But if the following operation is a store (`!`) then we will surely be writing garbage into some random location in memory. Again, an unrecoverable crash is almost guaranteed.

The importance of carefully tracking the parameter stack has long been known in the Forth world.
There is a long standing convention of documenting stack effects for all definitions.
Wouldn't it be great to have machine support which could help us check that our declared stack effects are correct.
Better still would be a system which could infer the stack effect for every definition we write;
by combining the known stack effect of primitive and previous user-defined words.
If no sensible stack effect is inferable, this should indicate a type error. And that type error would mean that a real error will happen at runtime. That's the golden standard we wish to aim for.


### Past work.


This is not a new idea.
But there is not very much literature describing type systems for Forth or it's concatenative cousins.

Here are some references:
- So and so provides the following short bibliography here...
- blog article
- languages: cat (Diggins), kitten, Mirth
- Strong Forth
- so and so's 1992 thesis
- Diggins's work ...

To my mind, the kinded-polymorphic system described by Diggins forms a strong base.

This builds upon the standard Damas-Hindley-Milner approach used for type checking functional languages, first worked out in the late 1970s for standard ML. Today HM is the bedrock of statically typed functional languages such as Ocaml and Haskell.

The core of the HM approach provides full type inference without requiring any user type annotations. Every term will have a principal type inferred. Which will be maximally polymorphic, given the restrictions of the type system. This core approach has worked incredibly well in the functional programming world, and is widely regarded as forming a nice sweet spot between simplicity and usefulness.

Could we get something similar for Forth? I think yes!


### Stack effects

Some primitives manipulate only basic types. For example, multiply `*`.
We would like to ascribe this a type which indicates it consumes two numbers from the stack, replacing with a fresh number. We write this type as follows:

```
* :: ( s Num Num -- s Num )
```

The `::` notation is borrowed from Haskell. It is not part of our executable programming language, but is just part of the type system.  We read `* ::` as _multiply has type_.

The `( ... -- ... )` is based on the the standard notation for a stack effects. It indicates the shape of the stack before and after the `*` is executed. For the primitive `*` we see that two numbers are consumed and one is generated.

But what is this `s`? We read this as _any stack_, and so the overall type indicates that `*` can operate on a stack of any depth, just so long as there are (at least) two numbers on top. The result will be a stack which is exactly the same except one item shallower; the top two numbers from the original stack being replaces with a new, perhaps different, number.


### Polymorphism

So what about the stack manipulation operators, for example `dup`. What type can be ascribed to this?
We find we need types which allow us to describe polymorphic stack effect, i.e.

```
dup :: ( s x -- s x x )
```

The type for `dup` is read as requiring a stack (`s`) with at least one item, of any type `x`. And resulting in a stack of exactly the same shape except this one item is replaced by two items of the given type.

Given these type for the primitives `dup` and `*`, the type inference system can tell us what the stack effect is for code sequences made up from these primitives.

For example the squaring function, or some other sequence:
```
: square   dup * ;
: umm      * * dup ;
```

These are the types we should expect to be inferred:
```
square :: ( s Num -- s Num )
umm    :: ( s Num Num Num -- s Num Num )
```

In both cases we have specialized the type of the `dup` primitive to be applicable to its use; `x` is replaced by `Num`. And also made use of a special inference rule for code concatenation:

```
If     codeA :: ( s1 -- s2 )
And:   codeB :: ( s2 -- s3 )

Then:  codeA codeB :: ( s1 -- s3 )
```

This rule forms the heart of the type inference system!


### Type inference for nip

As a further example of some primitive typings and expected inference, lets consider what types we will ascribe to the primitives `swap` and `drop`, and see the type inferred for a user definition of `nip`.

`swap` and `drop` are, like `dup`, polymorphic.

```
swap :: ( s x1 x2 --  s x2 x1 )
drop :: ( s x1 -- s )
```

As before `s` stands for any stack, but now we need multiple variables (`x1`, `x2`...) to stand for multiple, potentially different stack element types. We always write polymorphic type variables in lower case (following Haskell) which makes them easy to distinguish from concrete types such as `Num`. The alphabetic prefix of the type variable (`s` or `x`) is used to distinguish _stacks_ from _stack-elements_. These form separate _kinds_ in our type system. We will dig much deeper into this in a following article.

Now lets see the standard definition for `nip`. This definition comes complete with a user supplied stack effect comment, which although helpful for a human, is entirely ignore by the Forth system, and also by our budding type inference system.

```
: nip ( a b -- b ) swap drop ;
```

Along with the definition of `nip`, the only inputs to our type inference system are the primitive typings for `swap` and `drop`, and the rule for concatenation. Then the system will infer the following type for `nip`.

```
nip :: ( s x1 x2 -- s x2 )
```

### Engineering a useful type system

So far so good. But there is no real innovation here. This is the standard approach to inferring types in concatenative languages. But there are some special consideration needed for _Forth_, which derive from the fact that there is no clear distinction between _compile-time_ and _run-time_ in Forth.

There are also many question in how we build on the basics to engineer a useful type system, where the meaning of useful is as discussed above.

- What concrete types do we support? So far we have seen just `Num`.
- We'd like to see some example programs which are rejected by the type system!
- How do we deal with control flow: `if`, `then`, `exit`?
- How do we type check primitives such as `execute` which consume execution tokens?
- What about dictionary lookup: `find`, or [Quarter's](3.quarter.md) dispatch primitive (`?`).
- What about _fetch_ (`@`) and _store_ (`!`) ?
- What about _comma_ (`,`) and compile-comma (`compile,`) ?
- What about words which manipulate the return stack (`>r` and `r>`)


### Next time

In the [next article](5.type-system.md)
we'll explore some possible answers to the above questions. And see the limits of what we can usefully type check, and what is perhaps past that limit.
